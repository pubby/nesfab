/*
 * Copyright (c) 2024, Patrick Bene
 * This file is distributed under the Boost Software License, Version 1.0.
 * See LICENSE_1_0.txt or https://www.boost.org/LICENSE_1_0.txt 
 */

// This file is based on the work of Antoine Gohin (Broke Studio),
// with original copyright to him.
// See: https://github.com/BrokeStudio/rainbow-net/blob/master/NES/mapper-doc.md

///////////////////////////////////////////////////////////////////////////////
// Helper code for interfacing the RAINBOW mapper /////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// Basic registers:
ct AA RNBW_PRG_MODE           = $4100 // Don't use this!
ct AA RNBW_PRG_ROM_SELECT_HI  = $4108 // There are 8 of these. Don't use this!
ct AA RNBW_PRG_ROM_SELECT_LO  = $4118 // There are 8 of these. Don't use this!
ct AA RNBW_PRG_RAM_SELECT_HI  = $4106 // There are 2 of these. Don't use unless you know what you're doing!
ct AA RNBW_PRG_RAM_SELECT_LO  = $4116 // There are 2 of these. Don't use unless you know what you're doing!
ct AA RNBW_CHR_CTRL           = $4120
ct AA RNBW_BG_EXT_SELECT_HI   = $4121
ct AA RNBW_BG_FILL_PATTERN    = $4124
ct AA RNBW_BG_FILL_ATTR       = $4125
ct AA RNBW_NT_2000_SELECT     = $4126
ct AA RNBW_NT_2400_SELECT     = $4127
ct AA RNBW_NT_2800_SELECT     = $4128
ct AA RNBW_NT_2C00_SELECT     = $4129
ct AA RNBW_NT_2000_CTRL       = $412A
ct AA RNBW_NT_2400_CTRL       = $412B
ct AA RNBW_NT_2800_CTRL       = $412C
ct AA RNBW_NT_2C00_CTRL       = $412D
ct AA RNBW_NT_WINDOW_SELECT   = $412E
ct AA RNBW_NT_WINDOW_CTRL     = $412F
ct AA RNBW_CHR_SELECT_HI      = $4130 // There are 16 of these.
ct AA RNBW_CHR_SELECT_LO      = $4140 // There are 16 of these.

// Scanline IRQ registers:
ct AA RNBW_SCANLINE_LATCH     = $4150
ct AA RNBW_SCANLINE_ENABLE    = $4151 // Write
ct AA RNBW_SCANLINE_STATUS    = $4151 // Read
ct AA RNBW_SCANLINE_DISABLE   = $4152
ct AA RNBW_SCANLINE_OFFSET    = $4153

// IRQ m2 jitter counter: (counts cycles after IRQ)
ct AA RNBW_JITTER             = $4154

// CPU cycle IRQ registers:
ct AA RNBW_CYCLE_LATCH_HI     = $4158
ct AA RNBW_CYCLE_LATCH_LO     = $4159
ct AA RNBW_CYCLE_CTRL         = $415A
ct AA RNBW_CYCLE_ACK          = $415B

// ExRAM auto writer:
ct AA RNBW_EXRAM_AUTO_HI        = $415C
ct AA RNBW_EXRAM_AUTO_LO        = $415D
ct AA RNBW_EXRAM_AUTO_INCREMENT = $415E
ct AA RNBW_EXRAM_AUTO_DATA      = $415F
ct AA EXDATA = RNBW_EXRAM_AUTO_DATA // Shorter name for same register.

// Mapper info registers:
ct AA RNBW_VERSION            = $4160

// IRQ status:
ct AA RNBW_IRQ_STATUS         = $4161

// Vector manipulation:
ct AA RNBW_VECTOR_CTRL        = $416B
ct AA RNBW_NMI_HI             = $416C // Don't use this!
ct AA RNBW_NMI_LO             = $416D // Don't use this!
ct AA RNBW_IRQ_HI             = $416E
ct AA RNBW_IRQ_LO             = $416F

// Window mode registers:
ct AA RNBW_WINDOW_X_START     = $4170
ct AA RNBW_WINDOW_X_END       = $4171
ct AA RNBW_WINDOW_Y_START     = $4172
ct AA RNBW_WINDOW_Y_END       = $4173
ct AA RNBW_WINDOW_X_SCROLL    = $4174
ct AA RNBW_WINDOW_Y_SCROLL    = $4175

// Audio registers:
ct AA RNBW_SQ1_CTRL           = $41A0
ct AA RNBW_SQ1_LO             = $41A1
ct AA RNBW_SQ1_HI             = $41A2
ct AA RNBW_SQ2_CTRL           = $41A3
ct AA RNBW_SQ2_LO             = $41A4
ct AA RNBW_SQ2_HI             = $41A5
ct AA RNBW_SAW_ACC            = $41A6
ct AA RNBW_SAW_LO             = $41A7
ct AA RNBW_SAW_HI             = $41A8
ct AA RNBW_AUDIO_CTRL         = $41A9
ct AA RNBW_AUDIO_VOLUME       = $41AA

// Sprite extended mode registers:
ct AA RNBW_SPR_EXT_SELECT_LO   = $4200
ct AA RNBW_SPR_EXT_SELECT_HI   = $4240

// Slow routines:
ct AA RNBW_ROUTINE_SLOW_OAM          = $4280
ct AA RNBW_ROUTINE_SLOW_OAM_PAGE     = $4241
ct AA RNBW_ROUTINE_SLOW_SPR_EXT      = $4282
ct AA RNBW_ROUTINE_SLOW_SPR_EXT_PAGE = $4242

// RAM:
ct AA RNBW_NETRAM             = $4800
ct AA RNBW_EXRAM              = $5000

///////////////////////////////////////////////////////////////////////////////
// EXRAM //////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// Pointer to NETRAM (FPGA RAM for WiFi):
ct MM rnbw_netram = MM(RNBW_NETRAM)

// Pointer to ExRAM (also called FPGA RAM):
ct MM rnbw_exram = MM(RNBW_EXRAM)

// Sets the ExRAM auto reader/writer up:
fn rnbw_exram_auto(AA address, U increment)
: +inline
    {RNBW_EXRAM_AUTO_HI}(address.b)
    {RNBW_EXRAM_AUTO_LO}(address.a)
    {RNBW_EXRAM_AUTO_INCREMENT}(increment)

// Same as above, but doesn't set the increment.
fn rnbw_exram_auto_addr(AA address)
: +inline
    {RNBW_EXRAM_AUTO_HI}(address.b)
    {RNBW_EXRAM_AUTO_LO}(address.a)

fn rnbw_exram_upload_fill(U byte, UU count)
    for UU i = 0; i < count; i += 1
        {EXDATA}(byte)

///////////////////////////////////////////////////////////////////////////////
// CHR ////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// Use these when writing RNBW_CHR_CTRL:
ct U RNBW_CHR_CTRL_8K       = 0
ct U RNBW_CHR_CTRL_4K       = 1
ct U RNBW_CHR_CTRL_2K       = 2
ct U RNBW_CHR_CTRL_1K       = 3
ct U RNBW_CHR_CTRL_512B     = 4
ct U RNBW_CHR_CTRL_WINDOW   = %00010000
ct U RNBW_CHR_CTRL_SPR_EXT  = %00100000
ct U RNBW_CHR_CTRL_RAM      = %01000000
ct U RNBW_CHR_CTRL_FPGA_RAM = %10000000

// Changes the RNBW CHR bank:
fn rnbw_chr_select(U slot, UU chr_bank)
: +inline
    {RNBW_CHR_SELECT_HI + slot}(chr_bank.b)
    {RNBW_CHR_SELECT_LO + slot}(chr_bank.a)

// Use these to calculate CHR regions for background extended mode:
ct Int RNBW_BG_EXT_CHR_PAGE_SIZE = 262144
ct fn RNBW_BG_EXT_CHR_PAGE_ADDR(U page) Int
    return page * RNBW_BG_EXT_CHR_PAGE_SIZE

// Use these to calculate CHR regions for sprite extended mode:
ct fn RNBW_SPR_EXT_CHR_PAGE_SIZE(Bool spr_8x16)  Int
    if spr_8x16
        return 1048576 << 1
    return 1048576
ct fn RNBW_SPR_EXT_CHR_PAGE_ADDR(U page, Bool spr_8x16) Int
    return page * RNBW_SPR_EXT_CHR_PAGE_SIZE(spr_8x16)

///////////////////////////////////////////////////////////////////////////////
// Nametables /////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// Use these when writing to nametable control registers (RNBW_NT_2000_CTRL...)
ct U RNBW_NT_CTRL_ATTR_EXT     = %00000001
ct U RNBW_NT_CTRL_BG_EXT       = %00000010
ct U RNBW_NT_CTRL_EXT          = %00000011
ct U RNBW_NT_CTRL_EXT_BANK_0   = %00000000
ct U RNBW_NT_CTRL_EXT_BANK_1   = %00000100
ct U RNBW_NT_CTRL_EXT_BANK_2   = %00001000
ct U RNBW_NT_CTRL_EXT_BANK_3   = %00001100
ct U RNBW_NT_CTRL_FILL         = %00100000
ct U RNBW_NT_CTRL_CI_RAM       = %00000000
ct U RNBW_NT_CTRL_CHR_RAM      = %01000000
ct U RNBW_NT_CTRL_FPGA_RAM     = %10000000
ct U RNBW_NT_CTRL_CHR_ROM      = %11000000

// Selects the control for the 4 main nametables.
fn rnbw_nt_ctrl(U nt2000, U nt2400, U nt2800, U nt2c00)
: +inline
    {RNBW_NT_2000_CTRL}(nt2000)
    {RNBW_NT_2400_CTRL}(nt2400)
    {RNBW_NT_2800_CTRL}(nt2800)
    {RNBW_NT_2C00_CTRL}(nt2c00)

// Selects the control for the 4 main nametables.
fn rnbw_nt_ctrl_broad(U nt)
: +inline
    {RNBW_NT_2000_CTRL}(nt)
    {RNBW_NT_2400_CTRL}(nt)
    {RNBW_NT_2800_CTRL}(nt)
    {RNBW_NT_2C00_CTRL}(nt)

// Selects the bank for 4 main nametables.
fn rnbw_nt_select(U b2000, U b2400, U b2800, U b2c00)
: +inline
    {RNBW_NT_2000_SELECT}(b2000)
    {RNBW_NT_2400_SELECT}(b2400)
    {RNBW_NT_2800_SELECT}(b2800)
    {RNBW_NT_2C00_SELECT}(b2c00)

// Selects the bank for 4 main nametables.
fn rnbw_nt_select_broad(U b)
: +inline
    {RNBW_NT_2000_SELECT}(b)
    {RNBW_NT_2400_SELECT}(b)
    {RNBW_NT_2800_SELECT}(b)
    {RNBW_NT_2C00_SELECT}(b)

fn rnbw_bg_fill(U pattern, U attr)
: +inline
    {RNBW_BG_FILL_PATTERN, RNBW_BG_FILL_ATTR}(pattern, attr)

///////////////////////////////////////////////////////////////////////////////
// Sprites ////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// Sets a sprite's bank in extended sprite mode.
// NOTE: You should also set RNBW_SPR_EXT_SELECT_HI, which affects all sprites.
fn rnbw_spr_ext_select(U sprite_index, U chr_bank)
: +inline
    {RNBW_SPR_EXT_SELECT_LO + sprite_index}(chr_bank)

///////////////////////////////////////////////////////////////////////////////
// Interrupt Generators ///////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// Flags for RNBW_SCANLINE_ENABLE:
ct U RNBW_SCANLINE_ENABLE_PENDING  = %01000000
ct U RNBW_SCANLINE_ENABLE_IN_FRAME = %01000000
ct U RNBW_SCANLINE_ENABLE_HBLANK   = %10000000

// Blocks execution until a scanline is reached.
fn rnbw_scanline_await(U scanline)
: +inline
    {RNBW_SCANLINE_DISABLE}(scanline)
    {RNBW_SCANLINE_LATCH}(scanline)
    while {RNBW_SCANLINE_ENABLE}() & RNBW_SCANLINE_ENABLE_PENDING == 0

// Blocks execution until the frame starts to render.
fn rnbw_scanline_await_frame()
: +inline
    while {RNBW_SCANLINE_ENABLE}() & RNBW_SCANLINE_ENABLE_IN_FRAME == 0

// Triggers an IRQ on a specified scanline.
fn rnbw_scanline_async(U scanline)
: +inline
    {RNBW_SCANLINE_DISABLE}(scanline)
    {RNBW_SCANLINE_LATCH}(scanline)
    {RNBW_SCANLINE_ENABLE}(scanline)

// Flags for RNBW_CYCLE_CTRL:
ct U RNBW_CYCLE_CTRL_ENABLE   = %001
ct U RNBW_CYCLE_CTRL_REPEAT   = %010
ct U RNBW_CYCLE_CTRL_4011_ACK = %100

// Triggers an IRQ after a specified number of cycles:
fn rnbw_cycle_async(UU cycles, U flags)
: +inline
    {RNBW_CYCLE_CTRL}(0)
    {RNBW_CYCLE_LATCH_LO}(cycles.a)
    {RNBW_CYCLE_LATCH_HI}(cycles.b)
    {RNBW_CYCLE_CTRL}(RNBW_CYCLE_CTRL_ENABLE | flags)
    
///////////////////////////////////////////////////////////////////////////////
// Vectors ////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

ct U RNBW_VECTOR_CTRL_ENABLE_NMI = %01
ct U RNBW_VECTOR_CTRL_ENABLE_IRQ = %10

// It's *ONLY* possible to use Rainbow's IRQ redirect feature
// when using 'asm fn' irqs with '+solo_interrupt' and '+static'.
// The redirect addresses must point inside the 'asm fn' IRQ.
// 
// DO NOT redirect the NMI; this is not at all supported.

// Sets the IRQ redirect pointer without enabling/disabling it:
// NOTE: You probably want to disable IRQs before doing this!
fn rnbw_set_irq(AA addr)
: +inline
    {RNBW_IRQ_LO, RNBW_IRQ_HI}(addr.a, addr.b)

// Sets the IRQ redirect pointer and enables it:
// Note: Disables the redirect while writing.
fn rnbw_redirect_irq(AA addr)
: +inline
    {RNBW_VECTOR_CTRL}(0) // Disable
    {RNBW_IRQ_LO}(addr.a)
    {RNBW_IRQ_HI}(addr.b)
    {RNBW_VECTOR_CTRL}(RNBW_VECTOR_CTRL_ENABLE_IRQ) // Re-enable

///////////////////////////////////////////////////////////////////////////////
// Routines ///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// Runs the slow oam routine.
// NOTE: Set RNBW_ROUTINE_SLOW_OAM_PAGE first!
asm fn rnbw_routine_slow_oam()
: employs
: +static
    default
        jmp RNBW_ROUTINE_SLOW_OAM

// Runs the slow spr ext routine.
// NOTE: Set RNBW_ROUTINE_SLOW_SPR_EXT_PAGE first!
asm fn rnbw_routine_slow_spr_ext()
: employs
: +static
    default
        jmp RNBW_ROUTINE_SLOW_SPR_EXT

///////////////////////////////////////////////////////////////////////////////
// Audio //////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// Use these when writing to the audio control register:
ct U RNBW_AUDIO_CTRL_EXP6    = %00000001
ct U RNBW_AUDIO_CTRL_EXP9    = %00000010
ct U RNBW_AUDIO_CTRL_IPCM    = %00000100
ct U RNBW_AUDIO_CTRL_EXP_ALL = %00000011
ct U RNBW_AUDIO_CTRL_ALL     = %00000111
