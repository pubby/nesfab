/*
 * Copyright (c) 2023, Patrick Bene
 * This file is distributed under the Boost Software License, Version 1.0.
 * See LICENSE_1_0.txt or https://www.boost.org/LICENSE_1_0.txt 
 */

// Code for interfacing with the NES's hardware.

///////////////////////////////////////////////////////////////////////////////
// FLAGS //////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// Useful flags for manipulating the PPU.

// PPUMASK flags:
ct U PPUMASK_GRAYSCALE   = %00000001
ct U PPUMASK_NO_BG_CLIP  = %00000010
ct U PPUMASK_NO_SPR_CLIP = %00000100
ct U PPUMASK_BG_ON       = %00001000
ct U PPUMASK_SPR_ON      = %00010000
ct U PPUMASK_EMPHASIZE_R = %00100000
ct U PPUMASK_EMPHASIZE_G = %01000000
ct U PPUMASK_EMPHASIZE_B = %10000000
ct U PPUMASK_ON          = PPUMASK_BG_ON | PPUMASK_SPR_ON
ct U PPUMASK_NO_CLIP     = PPUMASK_NO_BG_CLIP | PPUMASK_NO_SPR_CLIP

// PPUCTRL flags:
ct U PPUCTRL_NT_2000      = %00000000
ct U PPUCTRL_NT_2400      = %00000001
ct U PPUCTRL_NT_2800      = %00000010
ct U PPUCTRL_NT_2C00      = %00000011
ct U PPUCTRL_VRAM_32_DOWN = %00000100
ct U PPUCTRL_SPR_PT_1000  = %00001000 // Ignored in 8x16 mode.
ct U PPUCTRL_BG_PT_1000   = %00010000
ct U PPUCTRL_SPR_8X16     = %00100000
ct U PPUCTRL_NMI_ON       = %10000000

// PPUSTATUS flags:
ct U PPUSTATUS_VBLANK        = %10000000
ct U PPUSTATUS_SPR_0         = %01000000
ct U PPUSTATUS_SPR_OVERFLOW  = %00100000

///////////////////////////////////////////////////////////////////////////////
// GENERAL PPU ////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// Sets PPUADDR.
fn ppu_set_addr(UU addr)
: +inline
    {PPUADDR}(addr.b)
    {PPUADDR}(addr.a)

// The same as above, but reset address latch first.
fn ppu_reset_addr(UU addr)
: +inline
    {PPUSTATUS}()
    ppu_set_addr(addr)

// Sets PPUSCROLL.
// When called during rendering mid-frame, only the X scroll will take effect;
// use 'ppu_set_mid_scroll' to set Y in those cases.
fn ppu_set_scroll(U x, U y)
: +inline
    {PPUSCROLL, PPUSCROLL}(x, y)

// The same as above, but reset address latch first.
fn ppu_reset_scroll(U x, U y)
: +inline
    {PPUSTATUS}()
    ppu_set_scroll(x, y)

// Sets X/Y scroll mid-frame.
// NOTE: Ideally, you want the last two writes to occur during HBLANK.
fn ppu_set_mid_scroll(U x, U y, U nt)
: +inline
    {PPUADDR}(nt << 2)
    {PPUSCROLL}(y)
    // Last two writes should be consecutive:
    {PPUSCROLL, PPUADDR}(x, ((y & $F8) << 2) | (x >> 3))

// The same as above, but reset address latch first.
fn ppu_reset_mid_scroll(U x, U y, U nt)
: +inline
    {PPUSTATUS}()
    ppu_set_mid_scroll(x, y, nt)

// Polls 'PPUSTATUS' until any bit of 'flag' is set.
asm fn ppu_await_status_set(U flag)
: +static
: +zero_page
: employs
    default 
        lda &flag
    label loop
        bit PPUSTATUS
        beq loop
        rts

// Polls 'PPUSTATUS' until no bit of 'flag' is set.
asm fn ppu_await_status_clear(U flag)
: +static
: +zero_page
: employs
    default 
        lda &flag
    label loop
        bit PPUSTATUS
        bne loop
        rts

// Polls 'PPUSTATUS' until no bit of 'flag' is set,
// then polls 'PPUSTATUS' until any bit of 'flag' is set.
// This is useful for checking sprite 0, among other things.
fn ppu_await_status(U flag)
: +inline
    ppu_await_status_clear(flag)
    ppu_await_status_set(flag)

// Uploads 'count' bytes of value' byte' to the PPU, using PPUDATA.
fn ppu_upload_fill(U byte, UU count)
: +inline
    for UU i = 0; i < count; i += 1
        {PPUDATA}(byte)

// Returns the nametable offset at tile (x, y).
fn nt_tile_offset(U x, U y) UU
: +inline
    return UU(x) + (UU(y) << 5)

// Returns the nametable attribute offset at tile (x, y).
fn nt_attr_offset(U x, U y) UU
: +inline
    return $3C0 + UU(x >> 2) + (UU(y & ~U(%11)) << 1)

///////////////////////////////////////////////////////////////////////////////
// NMI ////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// Waits a specified number of NMI frames, using the NMI handler.
fn wait(U frames)
: -inline
: +static
    for U i = 0; i < frames; i += 1
        nmi

// Waits a specified number of NMI frames, using PPUSTATUS polling.
fn wait_polled(U frames)
: -inline
: +static
    {PPUSTATUS}()
    for U i = 0; i < frames; i += 1
        while {PPUSTATUS}() < $80

///////////////////////////////////////////////////////////////////////////////
// OAM ////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// Code for manipulating OAM (Object Attribute Memory),
// which is the memory that represents sprites.
// See: https://www.nesdev.org/wiki/PPU_OAM

vars
    // This array represents the CPU-side copy of OAM.
    // Make your modifications to it, then call 'ppu_upload_oam' during VBLANK.
    U[256] oam
    : +align
    : -sram

// Offsets into OAM, as determined by the hardware:
ct Int OAM_Y = 0
ct Int OAM_P = 1
ct Int OAM_A = 2
ct Int OAM_X = 3

// OAM attribute flags:
ct U ATTR_PRIORITY = %00100000
ct U ATTR_H_FLIP   = %01000000
ct U ATTR_V_FLIP   = %10000000
ct U ATTR_HV_FLIP  = %11000000

// Copies 'oam' into PPU memory. Call during VBLANK only.
fn ppu_upload_oam(U oam_offset)
: employs
: +inline
: +static
    fence
    {OAMADDR}(oam_offset)
    {OAMDMA}((&oam).b)
    fence

// !!! For the following functions: !!!
// 'index' must be a multiple of 4, otherwise the behavior is undefined.

// Hides every sprite, starting from 'index':
fn hide_oam(U index)
: +inline
    do for ; index; index += 4
    : -unroll
        oam{OAM_Y + index} = $FF

// The 'set_oam' functions use the '{}' operator for array indexing 
// instead of '[]', as it's more efficient in this case.

fn set_oam_x(U index, U x)
: +inline
    oam{OAM_X + index} = x

fn set_oam_y(U index, U y)
: +inline
    oam{OAM_Y + index} = y

fn set_oam_p(U index, U p)
: +inline
    oam{OAM_P + index} = p

fn set_oam_a(U index, U a)
: +inline
    oam{OAM_A + index} = a

fn set_oam(U index, U x, U y, U p, U a)
: +inline
    oam{OAM_Y + index} = y
    oam{OAM_P + index} = p
    oam{OAM_A + index} = a
    oam{OAM_X + index} = x
    
fn push_oam(U index, U x, U y, U p, U a) U
: +inline
    set_oam(index, x, y, p, a)
    return index + 4

///////////////////////////////////////////////////////////////////////////////
// PAD ////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// Code for reading and handling gamepad button presses.
// See: https://www.nesdev.org/wiki/Standard_controller
// NOTE: In NESFab, use the --controllers option to set the desired number of controllers.

// Typically, the functions you want are: 'ppu_upload_oam_poll_pads' and 'update_pads'.

// Gamepad button flags:
ct U BUTTON_A      = %10000000
ct U BUTTON_B      = %01000000
ct U BUTTON_SELECT = %00100000
ct U BUTTON_START  = %00010000
ct U BUTTON_UP     = %00001000
ct U BUTTON_DOWN   = %00000100
ct U BUTTON_LEFT   = %00000010
ct U BUTTON_RIGHT  = %00000001
ct U BUTTON_DPAD   = BUTTON_UP | BUTTON_DOWN | BUTTON_LEFT | BUTTON_RIGHT

// This struct provides an interface to a single gamepad.
// To use, AND the fields with the button flags above.
struct Pad
    U held
    U pressed
    U released

vars
    // [0] for the first controller, [1] for the second
    Pad[__controllers] pads = Pad[__controllers]() // __controllers is set by --controllers option.

    U[__controllers] raw_pads = U[__controllers](0)
    : +zero_page

// Polls the current gamepad state into 'raw_pads'.
// This does not update 'pads'; use 'update_pads' subsequently for that.
// Ideally, you would call this in your NMI, once per frame.
// NOTE: This supports the NES Four Score, but no other expansion.
//       See "famicom.fab" if you need to support Famicom expansion controllers / Hori!
// NOTE: This is unsafe with the DMC glitch. Do not mix this with DPCM sounds!
fn poll_pads()
    ppu_upload_oam_poll_pads.done_oam(0)

// Polls the current gamepad state into 'raw_pads' while also uploading OAM.
// This does not update 'pads'; use 'update_pads' subsequently for that.
// Ideally, you would call this in your NMI, once per frame.
// NOTE: This supports the NES Four Score, but no other expansion.
//       See "famicom.fab" if you need to support Famicom expansion controllers / Hori!
// NOTE: This correctly handles the DMC glitch.
asm fn ppu_upload_oam_poll_pads(U oam_offset)
: employs
: +align
: +static
    default
        lda &oam_offset
        sta OAMADDR
        lda #(&oam).b
        sta OAMDMA
    label done_oam
        ldx #1
        stx &raw_pads+0
        stx $4016
        dex
        stx $4016
    label loop
        if __controllers > 1
            lda $4017
            lsr
            rol &raw_pads+1, x
        lda $4016
        lsr
        rol &raw_pads+0
        bcc loop

        if __controllers > 2
            lda #1
            sta &raw_pads+2
    label loop_four_score
        if __controllers > 2
            if __controllers > 3
                lda $4017
                lsr
                rol &raw_pads+3, x
            lda $4016
            lsr
            rol &raw_pads+2
            bcc loop_four_score

            // Check to make sure the four-score is enabled:
            if __controllers > 3
                lda $4017
                ora $4017
                eor $4017
            else
                lda $4016
                ora $4016
                ora $4016
                eor $4016
            lsr
            bcs done_four_score
            if __controllers > 3
                stx &raw_pads+3
            stx &raw_pads+2
    label done_four_score

        rts

// Polls a single pad, returning the result.
asm fn poll_pad(U pad_id) U
: employs
    default
        ldx #1
        stx &return
        stx $4016
        dex
        stx $4016
        ldx &pad_id
    label loop
        lda $4016, x
        lsr
        rol &return
        bcc loop
        rts

// Polls a single pad, returning the result.
// NOTE: This version correctly handles the DMC glitch.
fn poll_pad_safe(U pad_id) U
    U prev = poll_pad(pad_id)
    while true
        U next = poll_pad(pad_id)
        if next == prev
            return next
        prev = next

// Updates a single pad ('pad') with new input ('raw_held'), returning it.
fn update_pad(Pad pad, U raw_held) Pad
: +inline
    pad.pressed  = ~pad.held & raw_held
    pad.released = ~raw_held & pad.held
    pad.held = raw_held
    return pad

// Updates 'pads' based on the last polled state.
// Call 'poll_pads' or 'ppu_upload_oam_poll_pads' first.
// Ideally, you would call this at the start of your game logic
// (which may occur less than once per frame).
fn update_pads()
    for U i = 0; i < __controllers; i += 1
        pads[i] = update_pad(pads[i], raw_pads[i])

///////////////////////////////////////////////////////////////////////////////
// PALETTE ////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// Code for working with palettes,
// i.e. the limited set of colors the NES can display at once.
// See: https://www.nesdev.org/wiki/PPU_palettes
// !!! For more palette functions, see palette.fab !!!

// Copies the global variable 'palette' into the PPU's internal palette memory.
fn ppu_upload_palette()
: -inline
    {PPUSTATUS}()
    {PPUADDR}($3F)
    {PPUADDR}($00)

    {PPUDATA}(palette[PALETTE_UBC])
    {PPUDATA}(palette[0])
    {PPUDATA}(palette[1])
    {PPUDATA}(palette[2])

    {PPUDATA}(palette[PALETTE_UBC])
    {PPUDATA}(palette[3])
    {PPUDATA}(palette[4])
    {PPUDATA}(palette[5])

    {PPUDATA}(palette[PALETTE_UBC])
    {PPUDATA}(palette[6])
    {PPUDATA}(palette[7])
    {PPUDATA}(palette[8])

    {PPUDATA}(palette[PALETTE_UBC])
    {PPUDATA}(palette[9])
    {PPUDATA}(palette[10])
    {PPUDATA}(palette[11])

    {PPUDATA}(palette[PALETTE_UBC])
    {PPUDATA}(palette[12])
    {PPUDATA}(palette[13])
    {PPUDATA}(palette[14])

    {PPUDATA}(palette[PALETTE_UBC])
    {PPUDATA}(palette[15])
    {PPUDATA}(palette[16])
    {PPUDATA}(palette[17])

    {PPUDATA}(palette[PALETTE_UBC])
    {PPUDATA}(palette[18])
    {PPUDATA}(palette[19])
    {PPUDATA}(palette[20])

    {PPUDATA}(palette[PALETTE_UBC])
    {PPUDATA}(palette[21])
    {PPUDATA}(palette[22])
    {PPUDATA}(palette[23])

// 'palette' is read by 'ppu_upload_palette'.
// Changing this value does not alter the PPU state directly;
// one must call 'ppu_upload_palette' to do that.
//
// Although a palette is 32 bytes in PPU VRAM, 
// 7 of these bytes are mirrors of the first entry.
// Thus, 'palette' is size 25, with the mirrored entry positioned at the end.
vars
    U[25] palette = U[25]($0F)
    : +align

// To index into 'palette', these constants provide offsets:

ct Int PALETTE_BG  = 0  // First background palette entry
ct Int PALETTE_SPR = 12 // First sprite palette entry

// UBC means 'universal background color'.
// It's the 'palette' element mirrored to PPU addresses $3F00, $3F04, $3F08... etc.
ct Int PALETTE_UBC = 24

// An example palette, to modify:
ct U[25] example_palette = U[25](
    $11, $2B, $39,
    $13, $21, $3B,
    $15, $23, $31,
    $17, $25, $33,

    $02, $14, $26,
    $04, $16, $28,
    $06, $18, $2A,
    $08, $1A, $2C,

    $0F)

