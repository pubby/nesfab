/*
 * Copyright (c) 2025, Patrick Bene
 * This file is distributed under the Boost Software License, Version 1.0.
 * See LICENSE_1_0.txt or https://www.boost.org/LICENSE_1_0.txt 
 */

// This macro implements a key-value pool represented as an array with no gaps 
// between live objects. Because objects are moved around to fill gaps, 
// numeric indexes to objects in this pool are not stable and will get invalidated
// when deleting other objects. Key based indexes are fine.

// Macro parameters:
#:key_type:#    // The key type of each object (probably some kind of number).
#:value_type:#  // The value type of each object (probably a struct type).
#:max_objects:# // The maximum number of objects that can exist at once (but not more than 254)
#:name:#        // The name of the objects (e.g. "enemies")
#:group:#       // The optional vars group to insert variables in.

ct U #name#_max = #max_objects#

struct #=name=#KV
    #key_type# key
    #value_type# value

vars #group#
    U #name#_num = 0
    #=name=#KV[#max_objects#] #name#

// Removes all objects:
fn #name#_clear()
: +inline
    #name#_num = 0

// Removes the key-value-pair at position 'index'.
// Invalidates the last key-value-pair's index.
// When calling this while iterating, 'index' should not be incremented.
fn #name#_delete(I.#name# index)
: +inline
    #name#_num -= 1
    index[] = #name#[#name#_num]

// Creates a key-value-pair, returning its index but not assigning to it.
// If no more key-value-pairs can be created, returns BAD_OBJECT.
fn #name#_alloc() I.#name#
: -inline
    if #name#_num == #name#_max
        return BAD_OBJECT
    U index = #name#_num
    #name#_num += 1
    return index

// Creates and assigns a key-value-pair, returning its index.
// If no more key-value-pairs can be created, returns BAD_OBJECT.
fn #name#_new(#key_type# key, #value_type# value) U
: +inline
    if #name#_num == #name#_max
        return BAD_OBJECT
    U index = #name#_num
    #name#[index].key = key
    #name#[index].value = value
    #name#_num += 1
    return index

// Returns true if the object at position 'index' is allocated:
fn #name#_exists(I.#name# index) Bool
: +inline
    return index < #name#_num

// Returns the number of objects whose key matches 'key':
fn #name#_count(#key_type# key) U
: +inline
    U count = 0
    for I.#name# i = 0; i < #name#_num; i += 1
        if i[].key == key
            count += 1
    return count

// Returns the index of the first object whose key matches 'key',
// or BAD_OBJECT if one doesn't exist:
fn #name#_find(#key_type# key) I.#name#
    for I.#name# i = 0; i < #name#_num; i += 1
        if i[].key == key
            return i
    return BAD_OBJECT

// Removes all objects whose key matches 'key'.
// Invalidates object indexes (when deleting).
fn #name#_cull(#key_type# key)
    for I.#name# i = 0; i < #name#_num;
        if i[].key == key
            #name#_delete(i)
        else
            i += 1

// Replaces all objects whose keys equal 'key' with 'new_value':
fn #name#_replace(#key_type# key, #value_type# new_value)
    for I.#name# i = 0; i < #name#_num; i += 1
        if i[].key == key
            i[].value = new_value
